"""
Vulnerability Scanner
Main orchestrator for security testing with real vulnerability detection.

Author: Marc ArÃ©valo
Version: 1.0
"""

import logging
import time
from typing import List, Optional

from selenium.webdriver.common.by import By
from selenium.webdriver.remote.webdriver import WebDriver
from selenium.webdriver.remote.webelement import WebElement

from .http_interceptor import HTTPInterceptor
from .payload_library import Payload, PayloadLibrary
from .response_analyzer import ResponseAnalyzer, VulnerabilityDetection
from .security_report import SecurityReport

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """
    Main orchestrator for security vulnerability scanning.

    Coordinates HTTP interception, payload injection, and response analysis
    to detect real vulnerabilities.
    """

    def __init__(self, driver: WebDriver, base_url: str):
        """
        Initialize vulnerability scanner.

        Args:
            driver: Selenium WebDriver instance
            base_url: Base URL of application under test
        """
        self.driver = driver
        self.base_url = base_url
        self.interceptor = HTTPInterceptor()
        self.payload_library = PayloadLibrary()
        self.analyzer = ResponseAnalyzer()
        self.report = SecurityReport(target_url=base_url)

    def scan_sql_injection(
        self,
        input_element: WebElement,
        submit_element: Optional[WebElement] = None,
        url: Optional[str] = None,
    ) -> List[VulnerabilityDetection]:
        """
        Test input field for SQL injection vulnerabilities.

        Args:
            input_element: Input field to test
            submit_element: Submit button (optional)
            url: URL being tested (optional, uses current URL if not provided)

        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []
        payloads = self.payload_library.get_payloads("sql_injection")
        test_url = url or self.driver.current_url

        logger.info(
            f"Testing SQL injection with {len(payloads)} payloads on {test_url}"
        )

        for payload in payloads:
            try:
                # Clear interceptor
                self.interceptor.clear()
                self.interceptor.start()

                # Inject payload
                input_element.clear()
                input_element.send_keys(payload.value)

                if submit_element:
                    submit_element.click()
                    time.sleep(1)

                # Capture HTTP traffic
                self.interceptor.capture_from_driver(
                    self.driver,
                    test_type="sql_injection",
                    payload=payload.value,
                )

                # Analyze responses
                for transaction in self.interceptor.get_transactions():
                    vuln = self.analyzer.analyze_sql_injection(
                        response_body=transaction.response.body,
                        status_code=transaction.response.status_code,
                        url=transaction.request.url,
                        method=transaction.request.method,
                        payload=payload.value,
                    )

                    if vuln:
                        vulnerabilities.append(vuln)
                        self.report.add_vulnerability(vuln)
                        logger.warning(
                            f"SQL Injection vulnerability found with payload: {payload.name}"
                        )

                self.interceptor.stop()

            except Exception as e:
                logger.error(
                    f"Error testing SQL injection with payload '{payload.name}': {e}"
                )

        self.report.total_tests += len(payloads)
        return vulnerabilities

    def scan_xss(
        self,
        input_element: WebElement,
        submit_element: Optional[WebElement] = None,
        url: Optional[str] = None,
    ) -> List[VulnerabilityDetection]:
        """
        Test input field for XSS vulnerabilities.

        Args:
            input_element: Input field to test
            submit_element: Submit button (optional)
            url: URL being tested (optional)

        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []
        payloads = self.payload_library.get_payloads("xss")
        test_url = url or self.driver.current_url

        logger.info(f"Testing XSS with {len(payloads)} payloads on {test_url}")

        for payload in payloads:
            try:
                self.interceptor.clear()
                self.interceptor.start()

                # Inject payload
                input_element.clear()
                input_element.send_keys(payload.value)

                if submit_element:
                    submit_element.click()
                    time.sleep(1)

                # Capture HTTP traffic
                self.interceptor.capture_from_driver(
                    self.driver, test_type="xss", payload=payload.value
                )

                # Get page source to check if payload is reflected
                page_source = self.driver.page_source

                # Analyze responses
                for transaction in self.interceptor.get_transactions():
                    vuln = self.analyzer.analyze_xss(
                        response_body=transaction.response.body,
                        status_code=transaction.response.status_code,
                        url=transaction.request.url,
                        method=transaction.request.method,
                        payload=payload.value,
                    )

                    if vuln:
                        vulnerabilities.append(vuln)
                        self.report.add_vulnerability(vuln)
                        logger.warning(
                            f"XSS vulnerability found with payload: {payload.name}"
                        )

                # Also check page source
                if payload.value in page_source:
                    logger.warning(
                        f"XSS payload reflected in page source: {payload.name}"
                    )

                self.interceptor.stop()

            except Exception as e:
                logger.error(
                    f"Error testing XSS with payload '{payload.name}': {e}"
                )

        self.report.total_tests += len(payloads)
        return vulnerabilities

    def scan_command_injection(
        self,
        input_element: WebElement,
        submit_element: Optional[WebElement] = None,
        url: Optional[str] = None,
    ) -> List[VulnerabilityDetection]:
        """
        Test input field for command injection vulnerabilities.

        Args:
            input_element: Input field to test
            submit_element: Submit button (optional)
            url: URL being tested (optional)

        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []
        payloads = self.payload_library.get_payloads("command_injection")
        test_url = url or self.driver.current_url

        logger.info(
            f"Testing command injection with {len(payloads)} payloads on {test_url}"
        )

        for payload in payloads:
            try:
                self.interceptor.clear()
                self.interceptor.start()

                # Inject payload
                input_element.clear()
                input_element.send_keys(payload.value)

                if submit_element:
                    submit_element.click()
                    time.sleep(1)

                # Capture HTTP traffic
                self.interceptor.capture_from_driver(
                    self.driver,
                    test_type="command_injection",
                    payload=payload.value,
                )

                # Analyze responses
                for transaction in self.interceptor.get_transactions():
                    vuln = self.analyzer.analyze_command_injection(
                        response_body=transaction.response.body,
                        status_code=transaction.response.status_code,
                        url=transaction.request.url,
                        method=transaction.request.method,
                        payload=payload.value,
                    )

                    if vuln:
                        vulnerabilities.append(vuln)
                        self.report.add_vulnerability(vuln)
                        logger.warning(
                            f"Command injection vulnerability found with payload: {payload.name}"
                        )

                self.interceptor.stop()

            except Exception as e:
                logger.error(
                    f"Error testing command injection with payload '{payload.name}': {e}"
                )

        self.report.total_tests += len(payloads)
        return vulnerabilities

    def scan_authentication_bypass(
        self,
        username_field: WebElement,
        password_field: WebElement,
        submit_button: WebElement,
        url: Optional[str] = None,
    ) -> List[VulnerabilityDetection]:
        """
        Test login form for authentication bypass vulnerabilities.

        Args:
            username_field: Username input element
            password_field: Password input element
            submit_button: Submit button element
            url: URL being tested (optional)

        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []
        payloads = self.payload_library.get_payloads("sql_injection")
        test_url = url or self.driver.current_url

        logger.info(
            f"Testing authentication bypass with {len(payloads)} payloads on {test_url}"
        )

        for payload in payloads:
            try:
                self.interceptor.clear()
                self.interceptor.start()

                # Try payload in username field
                username_field.clear()
                username_field.send_keys(payload.value)
                password_field.clear()
                password_field.send_keys("any_password")

                submit_button.click()
                time.sleep(2)

                # Capture HTTP traffic
                self.interceptor.capture_from_driver(
                    self.driver, test_type="auth_bypass", payload=payload.value
                )

                # Analyze responses
                for transaction in self.interceptor.get_transactions():
                    vuln = self.analyzer.analyze_authentication_bypass(
                        response_body=transaction.response.body,
                        status_code=transaction.response.status_code,
                        url=transaction.request.url,
                        method=transaction.request.method,
                        payload=payload.value,
                    )

                    if vuln:
                        vulnerabilities.append(vuln)
                        self.report.add_vulnerability(vuln)
                        logger.warning(
                            f"Authentication bypass vulnerability found with payload: {payload.name}"
                        )

                self.interceptor.stop()

                # Navigate back to login page for next test
                self.driver.get(test_url)
                time.sleep(1)

            except Exception as e:
                logger.error(
                    f"Error testing authentication bypass with payload '{payload.name}': {e}"
                )

        self.report.total_tests += len(payloads)
        return vulnerabilities

    def scan_all_inputs(
        self, vulnerability_types: Optional[List[str]] = None
    ) -> List[VulnerabilityDetection]:
        """
        Automatically scan all input fields on current page.

        Args:
            vulnerability_types: List of vulnerability types to test
                                (default: ["sql_injection", "xss"])

        Returns:
            List of all detected vulnerabilities
        """
        if vulnerability_types is None:
            vulnerability_types = ["sql_injection", "xss"]

        vulnerabilities = []
        current_url = self.driver.current_url

        logger.info(
            f"Scanning all inputs on {current_url} for {vulnerability_types}"
        )

        try:
            # Find all input fields
            inputs = self.driver.find_elements(By.TAG_NAME, "input")
            textareas = self.driver.find_elements(By.TAG_NAME, "textarea")
            all_inputs = inputs + textareas

            logger.info(f"Found {len(all_inputs)} input fields")

            for idx, input_element in enumerate(all_inputs):
                input_type = input_element.get_attribute("type") or "text"

                # Skip non-text inputs
                if input_type in [
                    "submit",
                    "button",
                    "hidden",
                    "file",
                    "image",
                ]:
                    continue

                logger.info(f"Testing input {idx + 1}/{len(all_inputs)}")

                # Test for SQL injection
                if "sql_injection" in vulnerability_types:
                    vulns = self.scan_sql_injection(
                        input_element, url=current_url
                    )
                    vulnerabilities.extend(vulns)

                # Test for XSS
                if "xss" in vulnerability_types:
                    vulns = self.scan_xss(input_element, url=current_url)
                    vulnerabilities.extend(vulns)

                # Navigate back if page changed
                if self.driver.current_url != current_url:
                    self.driver.get(current_url)
                    time.sleep(1)

        except Exception as e:
            logger.error(f"Error during automatic input scanning: {e}")

        return vulnerabilities

    def get_report(self) -> SecurityReport:
        """
        Get current security report.

        Returns:
            Security report
        """
        return self.report

    def save_report(
        self,
        output_dir: str = "reports/security",
        formats: Optional[List[str]] = None,
    ) -> None:
        """
        Save security report to file(s).

        Args:
            output_dir: Output directory
            formats: List of formats ("json", "html", "markdown")
        """
        from pathlib import Path

        from .security_report import SecurityReportGenerator

        if formats is None:
            formats = ["json", "html", "markdown"]

        Path(output_dir).mkdir(parents=True, exist_ok=True)

        timestamp = time.strftime("%Y%m%d_%H%M%S")

        if "json" in formats:
            json_path = f"{output_dir}/security_report_{timestamp}.json"
            SecurityReportGenerator.generate_json_report(
                self.report, json_path
            )

        if "html" in formats:
            html_path = f"{output_dir}/security_report_{timestamp}.html"
            SecurityReportGenerator.generate_html_report(
                self.report, html_path
            )

        if "markdown" in formats:
            md_path = f"{output_dir}/security_report_{timestamp}.md"
            SecurityReportGenerator.generate_markdown_report(
                self.report, md_path
            )

        logger.info(f"Security reports saved to {output_dir}")
